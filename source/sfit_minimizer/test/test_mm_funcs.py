"""
Tests for the MulensModel functions = direct comparisons to Andy's fortran sfit.
"""
import numpy as np
import os.path
import sfit_minimizer
import MulensModel as mm

"""
# Next Step: 
- MulensModel updates?

# Thoughts on test data:

Should start by generating two perfect test datasets with only a few (but different numbers of) points each and with 
different values of fs, fb. Then, run through sfit.f to retrieve bmat, dvec, cmat, at several successive steps and then
final values and sigmas.

# Tests I need:

1. fixed blending for a single observatory
2. parallax

Remember: Don't over-complicate it. The above is over-complicated.

"""


mm.utils.MAG_ZEROPOINT = 18.
data_path = os.path.join(sfit_minimizer.DATA_PATH, 'MMTest')


class FortranSFitFile(object):
    """
    Class to parse the comparison file generated by the Fortran version of sfit.
    """

    def __init__(self, filename):
        input_file = open(filename, 'r')
        attr = None
        for line in input_file.readlines():
            str_vec = line.strip().split()
            if str_vec[0] == '#':
                attr = str_vec[-1]
            else:
                if len(str_vec) == 1:
                    value = float(str_vec[0])
                else:
                    # print(attr, str_vec)
                    value = np.array([float(item) for item in str_vec])

                self.__setattr__(attr, value)

        input_file.close()


class ComparisonTest(object):

    def __init__(self, datafiles=None, comp_dir=None, parameters_to_fit=None):
        # Get step size from directory name
        str_vec = comp_dir.split('_')
        self.fac = float(str_vec[-1])

        # Read in SFit results
        self.sfit_results = FortranSFitFile(
            os.path.join(data_path, 'Matrices', comp_dir, 'fort.60'))
        self.matrices = []
        for i in range(3):
            self.matrices.append(
                FortranSFitFile(
                    os.path.join(
                        data_path, 'Matrices', comp_dir,
                        'fort.{0}'.format(50 + i + 1))
                ))

        # parameters_to_fit
        self.parameters_to_fit = parameters_to_fit
        self.n_params = len(self.parameters_to_fit)
        self.initial_guess = self.matrices[0].a[0:self.n_params]

        self.datasets = []
        for filename in datafiles:
            #print(filename, self.initial_guess.shape)
            self.initial_guess = np.hstack((self.initial_guess, [1.0, 0.0]))
            #print(self.initial_guess.shape)

            data = mm.MulensData(
                file_name=os.path.join(data_path, filename), phot_fmt='mag')
            self.datasets.append(data)

        self.n_obs = len(self.datasets)

        self.model = mm.Model(
            {self.parameters_to_fit[i]: self.initial_guess[i] for i in range(
                self.n_params)})
        self.event = mm.Event(datasets=self.datasets, model=self.model)
        #self.event.fit_fluxes()

        self.my_func = sfit_minimizer.mm_funcs.PSPLFunction(
            self.event, self.parameters_to_fit)

    def run(self):
        self.test_3_iterations()
        self.test_final_results()

    def test_3_iterations(self):
        # Do comparisons
        # first 3 iterations
        new_guess = self.initial_guess
        for i in range(3):
            print('testing iteration', i)
            self.my_func.update_all(theta0=new_guess)
            #print(new_guess)
            #print(self.matrices[i].a)
            #print(self.my_func.event.fluxes)
            self._compare_vector(new_guess, self.matrices[i].a, decimal=3)
            self.compare_calcs(self.matrices[i])
            new_guess += self.my_func.step * self.fac

    def test_final_results(self):
        # Final results
        result = sfit_minimizer.minimize(
            self.my_func, x0=self.initial_guess, tol=1e-3,
            options={'step': 'adaptive'})

        sigmas = self.my_func.get_sigmas()
        # Values
        #print(self.my_func.theta)
        #print(self.sfit_results.a)
        #self._compare_vector(
        #    self.my_func.theta, self.sfit_results.a, decimal=2)
        for i, x in enumerate(self.my_func.theta):
            decimal = 3
            if np.round(x / sigmas[i]) < decimal:
                decimal = np.round(x / sigmas[i])

            ind_i = self._get_index(i)
            #print(i, ind_i, x, sigmas[i], self.sfit_results.a[ind_i])
            assert( np.abs(x - self.sfit_results.a[ind_i]) < sigmas[i])

        # sigmas
        self._compare_vector(
           sigmas, self.sfit_results.s, decimal=2)

    def compare_calcs(self, sfit_matrix):
        # chi2
        if isinstance(sfit_matrix.chi2, (list, np.ndarray)):
            if len(self.datasets) != len(sfit_matrix.chi2):
                raise ValueError(
                    'Number of sfit chi2s != number of datasets: {0}, {1}'.format(
                        len(self.datasets), len(sfit_matrix.chi2)))

        else:
            sfit_matrix.chi2 = [sfit_matrix.chi2]

        for i in range(len(self.datasets)):
            # print(i)
            #print('sfit', sfit_matrix.chi2[i])
            #print('my_func', self.my_func.event.get_chi2_for_dataset(i))
            # print('fluxes', self.my_func.event.fluxes)
            # print('model', self.my_func.event.model.parameters)
            np.testing.assert_almost_equal(
                np.sum(sfit_matrix.chi2[i]) /
                self.my_func.event.get_chi2_for_dataset(i), 1.)

        # b matrix
        n_elements = int(np.sqrt(len(sfit_matrix.b)))
        shape = (n_elements, n_elements)
        bmat = sfit_matrix.b.reshape(shape)
        self._compare_matrix(self.my_func.bmat, bmat)

        # d vector
        #print('my d', self.my_func.dvec)
        #print('sfit d', sfit_matrix.d)
        self._compare_vector(self.my_func.dvec, sfit_matrix.d)

        # c matrix
        cmat = sfit_matrix.c.reshape(shape)
        #print('my c', self.my_func.cmat)
        #print('sfit c', cmat)
        #print('ratio ulens', self.my_func.cmat[0:3, 0:3] / cmat[0:3, 0:3])
        self._compare_matrix(self.my_func.cmat, cmat, decimal=4)

        # step
        self._compare_vector(self.my_func.step, sfit_matrix.da)

    def _get_index(self, i):
        """
        Fortran SFit includes a bunch of properties I'm not using
        (e.g., gammas, fsee).

        sfit count: 0-3: t0, u0, tE, rho
                    4-6: gammai,v,h
                    7-8: piEn,e
                    9-11: fs_i, fb_i, fsee_i
        """

        if i < self.n_params:
            # ulens parameters
            if self.parameters_to_fit[i] == 't_0':
                index = 0
            elif self.parameters_to_fit[i] == 'u_0':
                index = 1
            elif self.parameters_to_fit[i] == 't_E':
                index = 2
            elif self.parameters_to_fit[i] == 'rho':
                index = 3
            elif self.parameters_to_fit[i] == 'pi_E_N':
                index = 7
            elif self.parameters_to_fit[i] == 'pi_E_E':
                index = 8
            else:
                raise IndexError('i > n_params')
        else:
            # flux parameters (don't know if this will work for fixed blending)
            # i = n_params + 2. * n + 0; fs
            # i = n_params + 2. * n + 1; fb
            # index = 9 + 3 * n + 0; fs
            # index = 9 + 3 * n + 1 ; fb
            ftype = (i - self.n_params) % 2
            n = (i - self.n_params) / 2.
            if ftype == 1:
                n -= 0.5

            index = int(9. + ftype + np.round(n) * 3)
            #print('inds:', i, ftype, n, index)

        return index

    def _compare_vector(self, my_vector, sfit_vector, decimal=5):
        for i, value in enumerate(my_vector):
            index = self._get_index(i)

            #print(i, index)
            if value != 0.0:
                np.testing.assert_almost_equal(
                    value / sfit_vector[index], 1., decimal=decimal)
            else:
                np.testing.assert_almost_equal(
                    value,  sfit_vector[index], decimal=decimal)

    def _compare_matrix(self, my_matrix, sfit_matrix, verbose=False, decimal=5):
        n_elements = my_matrix.shape[0]
        #print('my', my_matrix.shape)
        #print('sfit', sfit_matrix.shape)
        for i in range(n_elements):
            ind_i = self._get_index(i)
            for j in range(n_elements):
                ind_j = self._get_index(j)
                if verbose:
                    print(
                        i, j, ind_i, ind_j)
                    print(my_matrix[i, j],
                        sfit_matrix[ind_i, ind_j])

                if my_matrix[i, j] != 0.0:
                    np.testing.assert_almost_equal(
                        my_matrix[i, j] / sfit_matrix[ind_i, ind_j], 1.,
                        decimal=decimal)
                else:
                    np.testing.assert_almost_equal(
                        my_matrix[i, j], sfit_matrix[ind_i, ind_j], decimal=decimal)


def test_cmat():
    datafiles = ['PSPL_1_Obs_1.pho', 'PSPL_1_Obs_2.pho']
    parameters_to_fit = ['t_0', 'u_0', 't_E']
    comparison_dir = 'PSPL_1_{0}'.format(0.1)
    print(comparison_dir)

    test = ComparisonTest(
        datafiles=datafiles, comp_dir=comparison_dir,
        parameters_to_fit=parameters_to_fit)
    test.my_func.update_all(theta0=test.initial_guess)

    n_elements = int(np.sqrt(len(test.matrices[0].c)))
    shape = (n_elements, n_elements)
    sfit_cmat = test.matrices[0].c.reshape(shape)

    for i in range(test.n_params):
        ind_i = test._get_index(i)
        for j in range(test.n_params):
            ind_j = test._get_index(j)
            my_el = test.my_func.cmat[i, j]
            #sig_el = np.sqrt(
            #s    test.matrices[0].s[ind_i] * test.matrices[0].s[ind_j])
            sfit_el = sfit_cmat[ind_i, ind_j]
            #guess = my_el / np.sqrt(test.my_func.cmat[i, i] * test.my_func.cmat[j, j])
            #print('my, sfit, guess')
            #print(i, j, ind_i, ind_j)
            #print(my_el, sfit_el, guess)
            if np.abs(sfit_el) > 1.:
                np.testing.assert_almost_equal(my_el / sfit_el, 1., decimal=6)
            else:
                np.testing.assert_almost_equal(my_el, sfit_el, decimal=6)


def test_pspl_1():
    datafiles = ['PSPL_1_Obs_1.pho', 'PSPL_1_Obs_2.pho']
    parameters_to_fit = ['t_0', 'u_0', 't_E']
    for fac in [0.1, 0.01]:
        comparison_dir = 'PSPL_1_{0}'.format(fac)
        print(comparison_dir)
        test = ComparisonTest(
            datafiles=datafiles, comp_dir=comparison_dir,
            parameters_to_fit=parameters_to_fit)
        test.run()


def test_pspl_2():
    datafiles = ['PSPL_2_Obs_1.pho']
    parameters_to_fit = ['t_0', 'u_0', 't_E']
    for fac in [0.1, 0.01]:
        comparison_dir = 'PSPL_2_{0}'.format(fac)
        print(comparison_dir)
        test = ComparisonTest(
            datafiles=datafiles, comp_dir=comparison_dir,
            parameters_to_fit=parameters_to_fit)
        test.run()


if __name__ == '__main__':
    test_pspl_1()
