"""
Tests for the MulensModel functions = direct comparisons to Andy's fortran sfit.
"""
import numpy as np
import os.path
import sfit_minimizer
import MulensModel as mm

"""
# Next Step: 
- MulensModel updates?

# Thoughts on test data:

Should start by generating two perfect test datasets with only a few (but different numbers of) points each and with 
different values of fs, fb. Then, run through sfit.f to retrieve bmat, dvec, cmat, at several successive steps and then
final values and sigmas.

# Tests:

1. single dataset
2. both datasets
3. fixing fb = 0 for one datasets
4. fixing fs = X for one dataset
5. Different step sizes: fixed, adaptive
6. with parallax
7. One parameter offset, all parameters offset
8. Test results for a dataset with many points.

Remember: Don't over-complicate it. The above is over-complicated.

"""

data_path = os.path.join(sfit_minimizer.DATA_PATH, 'MMTest')


class FortranSFitFile(object):
    """
    Class to parse the comparison file generated by the Fortran version of sfit.
    """

    def __init__(self, filename):
        input_file = open(filename, 'r')
        attr = None
        for line in input_file.readlines():
            str_vec = line.strip().split()
            if str_vec[0] == '#':
                attr = str_vec[-1]
            else:
                if len(str_vec) == 1:
                    value = float(str_vec[0])
                else:
                    print(attr, str_vec)
                    value = np.array([float(item) for item in str_vec])

                self.__setattr__(attr, value)

        input_file.close()


class ComparisonTest(object):

    def __init__(self, datafiles=None, comp_dir=None, parameters_to_fit=None):
        # Get step size from directory name
        str_vec = comp_dir.split('_')
        self.fac = float(str_vec[-1])

        # Read in SFit results
        self.sfit_results = FortranSFitFile(
            os.path.join(data_path, 'Matrices', comp_dir, 'fort.60'))
        self.matrices = []
        for i in range(3):
            self.matrices.append(
                FortranSFitFile(
                    os.path.join(
                        data_path, 'Matrices', comp_dir,
                        'fort.{0}'.format(50 + i + 1))
                ))

        # parameters_to_fit
        self.parameters_to_fit = parameters_to_fit
        self.n_params = len(self.parameters_to_fit)
        self.initial_guess = self.matrices[0].a[0:self.n_params]

        self.datasets = []
        for filename in datafiles:
            print(filename, self.initial_guess.shape)
            self.initial_guess = np.hstack((self.initial_guess, [1.0, 0.0]))
            print(self.initial_guess.shape)

            data = mm.MulensData(
                file_name=os.path.join(data_path, filename), phot_fmt='mag')
            self.datasets.append(data)

        self.n_obs = len(self.datasets)

        self.model = mm.Model(
            {self.parameters_to_fit[i]: self.initial_guess[i] for i in range(
                self.n_params)})
        self.event = mm.Event(datasets=self.datasets, model=self.model)
        self.event.fit_fluxes()

        self.my_func = sfit_minimizer.mm_funcs.PSPLFunction(
            self.event, self.parameters_to_fit)

    def run(self):
        self.test_3_iterations()
        self.test_final_results()

    def test_3_iterations(self):
        # Do comparisons
        # first 3 iterations
        new_guess = self.initial_guess
        for i in range(3):
            self.my_func.update_all(theta0=new_guess)
            self.compare_calcs(self.matrices[i])
            new_guess += self.my_func.step * self.fac

    def test_final_results(self):
        # Final results
        result = sfit_minimizer.minimize(
            self.my_func, x0=self.initial_guess, tol=1e-3,
            options={'step': 'adaptive'})
        # Values
        self._compare_vector(self.my_func.theta, result.a)

        # sigmas
        self._compare_vector(self.my_func.get_sigmas, result.s)

    def compare_calcs(self, sfit_matrix):
        # chi2
        np.testing.assert_almost_equal(
            np.sum(sfit_matrix.chi2), self.my_func.chi2)

        # b matrix
        n_elements = int(np.sqrt(len(sfit_matrix.b)))
        shape = (n_elements, n_elements)
        bmat = sfit_matrix.b.reshape(shape)
        self._compare_matrix(self.my_func.bmat, bmat)

        # c matrix
        cmat = sfit_matrix.c.reshape(shape)
        self._compare_matrix(self.my_func.cmat, cmat)

        # d vector
        self._compare_vector(self.my_func.dvec, sfit_matrix.d, )
        # step
        self._compare_vector(self.my_func.step, sfit_matrix.da)

    def _get_index(self, i):
        """
        Fortran SFit includes a bunch of properties I'm not using
        (e.g., gammas, fsee).

        sfit count: 0-3: t0, u0, tE, rho
                    4-6: gammai,v,h
                    7-8: piEn,e
                    9-11: fs_i, fb_i, fsee_i
        """

        if i < self.n_params:
            # ulens parameters
            if self.parameters_to_fit[i] == 't_0':
                index = 0
            elif self.parameters_to_fit[i] == 'u_0':
                index = 1
            elif self.parameters_to_fit[i] == 't_E':
                index = 2
            elif self.parameters_to_fit[i] == 'rho':
                index = 3
            elif self.parameters_to_fit[i] == 'pi_E_N':
                index = 7
            elif self.parameters_to_fit[i] == 'pi_E_E':
                index = 8
            else:
                raise IndexError('i > n_params')
        else:
            # flux parameters (don't know if this will work for fixed blending)
            ftype = (i - self.n_params) % 2
            n = np.floor((i - self.n_params) % self.n_obs)
            index = 9 + ftype + n * 3 * self.n_obs

        return index

    def _compare_vector(self, my_vector, sfit_vector):
        for i, value in enumerate(my_vector):
            index = self._get_index(i)

            print(i, index)
            np.testing.assert_almost_equal(value, sfit_vector[index])

    def _compare_matrix(self, my_matrix, sfit_matrix):
        n_elements = my_matrix.shape[0]
        for i in range(n_elements):
            ind_i = self._get_index(i)
            for j in range(n_elements):
                ind_j = self._get_index(j)
                print(
                    i, j, ind_i, ind_j, my_matrix[i, j],
                    sfit_matrix[ind_i, ind_j])
                np.testing.assert_almost_equal(
                    my_matrix[i, j], sfit_matrix[ind_i, ind_j])


def test_pspl_1():
    datafiles = ['PSPL_1_Obs_1.pho', 'PSPL_1_Obs_2.pho']
    parameters_to_fit = ['t_0', 'u_0', 't_E']
    for fac in [0.1, 0.01]:
        comparison_dir = 'PSPL_1_{0}'.format(fac)
        print(comparison_dir)
        test = ComparisonTest(
            datafiles=datafiles, comp_dir=comparison_dir,
            parameters_to_fit=parameters_to_fit)
        test.run()


def test_pspl_2():
    datafiles = ['PSPL_2_Obs_1.pho']
    parameters_to_fit = ['t_0', 'u_0', 't_E']
    for fac in [0.1, 0.01]:
        comparison_dir = 'PSPL_2_{0}'.format(fac)
        print(comparison_dir)
        test = ComparisonTest(
            datafiles=datafiles, comp_dir=comparison_dir,
            parameters_to_fit=parameters_to_fit)
        test.run()


if __name__ == '__main__':
    test_pspl_1()
